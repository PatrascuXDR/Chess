#include <iostream>
#include <conio.h>
#include <chrono>
#include <thread>
#include <windows.h>
using namespace std;
char a[9][9], piese[17] = {'R', 'r', 'N', 'n', 'B', 'b', 'K', 'k', 'Q', 'q', 'B', 'b', 'N', 'n', 'R', 'r'}, hhh, c;
int i, j, x, y, xx, yy, castigator, mesaj, ep[2], cursor[2] = {4, 4};
const int n = 8;
bool mutare = 1, remalb, remneg, recitire, reluare, veriff, rocadalb = 1, rocadneg = 1, cedat, rem, show_menu;
void gotoXY(int x, int y){
    COORD c{(SHORT)x, (SHORT)y};
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), c);
}
void ShowConsoleCursor(bool showFlag)
{
    HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_CURSOR_INFO cursorInfo;
    GetConsoleCursorInfo(out, &cursorInfo);
    cursorInfo.bVisible = showFlag;
    SetConsoleCursorInfo(out, &cursorInfo);
}
void MainMenu()
{
    system("cls");
    cout << "  ___   _     _   ___   ____  ____\n";
    cout << " | __| | |   | | | __| /   / /   /\n";
    cout << " ||    | |___| | ||_   |  |  |  |\n";
    cout << " ||    | |___| | ||_|   |  |  |  | \n";
    cout << " ||__  | |   | | ||__    |  |  |  |\n";
    cout << " |___| |_|   |_| |___|  /__/  /__/\n";
    cout << "\n\n\nApasa SPACE pentru a incepe";
    cout << "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";
    cout << "Introdu 'h' pentru meniul Help sau ` pentru a inchide jocul\n";
}
void intro()
{
    cout << "  ___\n";
    cout << " | __|\n";
    cout << " ||   \n";
    cout << " ||\n";
    cout << " ||__   \n";
    cout << " |___|\n";
    this_thread::sleep_for(chrono::milliseconds(700));
    system("cls");
    cout << "  ___   _     _ \n";
    cout << " | __| | |   | |\n";
    cout << " ||    | |___| |\n";
    cout << " ||    | |___| |\n";
    cout << " ||__  | |   | |\n";
    cout << " |___| |_|   |_|\n";
    this_thread::sleep_for(chrono::milliseconds(700));
    system("cls");
    cout << "  ___   _     _   ___ \n";
    cout << " | __| | |   | | | __|\n";
    cout << " ||    | |___| | ||_  \n";
    cout << " ||    | |___| | ||_|\n";
    cout << " ||__  | |   | | ||__ \n";
    cout << " |___| |_|   |_| |___|\n";
    this_thread::sleep_for(chrono::milliseconds(700));
    system("cls");
    cout << "  ___   _     _   ___   ____\n";
    cout << " | __| | |   | | | __| /   /\n";
    cout << " ||    | |___| | ||_   |  | \n";
    cout << " ||    | |___| | ||_|   |  |\n";
    cout << " ||__  | |   | | ||__    |  |\n";
    cout << " |___| |_|   |_| |___|  /__/\n";
    this_thread::sleep_for(chrono::milliseconds(700));
    MainMenu();
}
void outro()
{
    system("cls");
    cout << "  ___   _     _   ___   ____  ____\n";
    cout << " | __| | |   | | | __| /   / /   /\n";
    cout << " ||    | |___| | ||_   |  |  |  |\n";
    cout << " ||    | |___| | ||_|   |  |  |  | \n";
    cout << " ||__  | |   | | ||__    |  |  |  |\n";
    cout << " |___| |_|   |_| |___|  /__/  /__/\n";
    this_thread::sleep_for(chrono::milliseconds(700));
    system("cls");
    cout << "  ___   _     _   ___   ____\n";
    cout << " | __| | |   | | | __| /   /\n";
    cout << " ||    | |___| | ||_   |  | \n";
    cout << " ||    | |___| | ||_|   |  |\n";
    cout << " ||__  | |   | | ||__    |  |\n";
    cout << " |___| |_|   |_| |___|  /__/\n";
    this_thread::sleep_for(chrono::milliseconds(700));
    system("cls");
    cout << "  ___   _     _   ___ \n";
    cout << " | __| | |   | | | __|\n";
    cout << " ||    | |___| | ||_  \n";
    cout << " ||    | |___| | ||_|\n";
    cout << " ||__  | |   | | ||__ \n";
    cout << " |___| |_|   |_| |___|\n";
    this_thread::sleep_for(chrono::milliseconds(700));
    system("cls");
    cout << "  ___   _     _ \n";
    cout << " | __| | |   | |\n";
    cout << " ||    | |___| |\n";
    cout << " ||    | |___| |\n";
    cout << " ||__  | |   | |\n";
    cout << " |___| |_|   |_|\n";
    this_thread::sleep_for(chrono::milliseconds(700));
    system("cls");
    cout << "  ___\n";
    cout << " | __|\n";
    cout << " ||   \n";
    cout << " ||\n";
    cout << " ||__   \n";
    cout << " |___|\n";
    this_thread::sleep_for(chrono::milliseconds(700));
    system("cls");
}
void help()
{
    mesaj = 1;
        while (true){
            if (mesaj == 1){
                system("cls");
                cout << "Sistem de mutare:\nCursorul (<) se poate misca folosind WASD.\n La apasarea tastei ENTER se introduc automat randul si coloana.\n Selectati piesa si casuta pe care vreti sa mutati piesa.\n\n1/3\n\n";
                cout << "a si d pentru a schimba hint-ul sau s pentru a te intoarce\n\n";
                hhh = getch();
                if (GetAsyncKeyState('A') & 0x0001) mesaj --;
                else if (GetAsyncKeyState('D') & 0x0001) mesaj ++;
                else if (GetAsyncKeyState('S') & 0x0001) {MainMenu(); break;}
                if (mesaj < 1) mesaj = 1;
            }
            else if (mesaj == 2){
                system("cls");
                cout << "Comenzi speciale:\nPentru a ceda se introduce caracterul '-', iar pentru a cere o remiza se introduce '='\nDaca se introduce = de 2 ori la rand meciul se termina cu egalitate\nDupa introducerea caracterului '=' se introduc alte 4 valori normale\n\n2/3\n\n";
                cout << "a si d pentru a schimba hint-ul sau s pentru a te intoarce\n\n";
                hhh = getch();
                if (GetAsyncKeyState('A') & 0x0001) mesaj --;
                else if (GetAsyncKeyState('D') & 0x0001) mesaj ++;
                else if (GetAsyncKeyState('S') & 0x0001) {MainMenu(); break;}
            }
            else if (mesaj == 3){
                system("cls");
                cout << "Alte aspecte:\nSah-mat poate fi dat oricand capturand regele adversarului (daca este posibil).\nNu este necesara o situatie reala 'sah-mat', daor un moment de neatentie.\n\n3/3\n\n";
                cout << "a si d pentru a schimba hint-ul sau s pentru a te intoarce\n\n";
                hhh = getch();
                if (GetAsyncKeyState('A') & 0x0001) mesaj --;
                else if (GetAsyncKeyState('D') & 0x0001) mesaj ++;
                else if (GetAsyncKeyState('S') & 0x0001) {MainMenu(); break;}
                if (mesaj > 3) mesaj = 3;
            }
        }
}
void loading()
{
    system("cls");
    cout << "Se incarca.";
    this_thread::sleep_for(chrono::milliseconds(200));
    cout << ".";
    this_thread::sleep_for(chrono::milliseconds(200));
    cout << ".";
    this_thread::sleep_for(chrono::milliseconds(200));
    system("cls");
    cout << "Se incarca.";
    this_thread::sleep_for(chrono::milliseconds(200));
    cout << ".";
    this_thread::sleep_for(chrono::milliseconds(200));
    cout << ".";
    this_thread::sleep_for(chrono::milliseconds(200));
}
void setup()
{
    cedat = rem = 0; mutare = 1;
    rocadalb = 1; rocadneg = 1;
    for (j = 1; j <= n; j ++){
        a[2][j] = 'p';
        a[7][j] = 'P';
    }
    for (j = 1; j <= n; j ++){
        a[8][j] = piese[2 * j - 2];
        a[1][j] = piese[2 * j - 1];
    }
    for (i = 3; i <= 6; i ++){
        for (j = 1; j <= n; j ++){
            a[i][j] = NULL;
        }
    }
}
void afisare()
{
    gotoXY(0, 0);
    for (i = 1; i <= n; i ++) cout << "   " << i << "  ";
    cout << "\n";
    for (i = 1; i <= n; i ++) cout << "______";
    cout << "\n\n";
    cout << "|  ";
    for (i = 1; i <= n; i ++){
        for (j = 1; j <= n; j ++){
            if (i != cursor[0] || j != cursor[1]){
                if (a[i][j]) cout << a[i][j]  << "  |  ";
                else cout << "   |  ";
            }
            else{
                if (a[i][j]) cout << a[i][j]  << "< |  ";
                else cout << " < |  ";
            }
        }
        cout << i;
        cout << "\n";
        for (j = 1; j <= n; j ++) cout << "______";
        cout << "\n\n";
        if (i < n) cout << "|  ";
    }
    if (mutare){
        cout << "ALBUL LA MUTARE ";
        if (remneg) cout << " - Remiza?\n";
        else cout <<"\n";
    }
    else{
        cout << "NEGRUL LA MUTARE";
        if (remalb) cout << " - Remiza?\n";
        else cout <<"\n";
    }
    cout << x << " " << y << " " << xx << " " << yy;
}
int verif()
{
    if (mutare && (a[x][y] <= 'A' || a[x][y] >= 'Z')) return 0; // previne mutarea pieselor adversarului
    if (!mutare && (a[x][y] <= 'a' || a[x][y] >= 'z')) return 0;
    if (x == xx && y == yy) return 0; //piesele nu se mai pot captura singure
    if (a[x][y] >= 'a' && a[x][y] <= 'z' && a[xx][yy] >= 'a' && a[xx][yy] <= 'z') return 0; //Friendly fire will not be tolerated
    if (a[x][y] >= 'A' && a[x][y] <= 'Z' && a[xx][yy] >= 'A' && a[xx][yy] <= 'Z') return 0; //Friendly fire will not be tolerated
    if (a[x][y] == NULL) return 0; // previne mutarea unei piese inexistente
    // caz En Passant
    if (a[x][y] == 'p' && xx == ep[0] && yy == ep[1]){ a[xx - 1][yy] = NULL; return 1;}
    if (a[x][y] == 'P' && xx == ep[0] && yy == ep[1]){ a[xx + 1][yy] = NULL; return 1;}
    // rocada
    if (mutare && rocadalb && a[x][y] == 'K' && abs(y - yy) == 2){
        if (y > yy){
            for (i = y - 1; i >= yy; i --) if (a[n][i] != NULL) break;
            if (i >= yy) return 0;
            a[n][1] = NULL;
            a[n][yy + 1] = 'R';
            return 1;
        }
        else{
            for (i = y + 1; i <= yy; i ++) if (a[n][i] != NULL) break;
            if (i <= yy) return 0;
            a[n][n] = NULL;
            a[n][yy - 1] = 'R';
            return 1;
        }
    }
    if (!mutare && rocadneg && a[x][y] == 'k' && abs(y - yy) == 2){
        if (y > yy){
            for (i = y - 1; i >= yy; i --) if (a[1][i] != NULL) break;
            if (i >= yy) return 0;
            a[1][1] = NULL;
            a[1][yy + 1] = 'r';
            return 1;
        }
        else{
            for (i = y + 1; i <= yy; i ++) if (a[1][i] != NULL) break;
            if (i <= yy) return 0;
            a[1][n] = NULL;
            a[1][yy - 1] = 'r';
            return 1;
        }
    }
    if (a[x][y] == 'p' || a[x][y] == 'P'){
        if (xx < 1 || xx > 8) return 0;
        if (a[x][y] == 'p'){
            //pion blocat
            if (a[x + 1][y] != NULL && (a[x + 1][y - 1] == NULL && a[x + 1][y + 1] == NULL)) return 0;
            //atac
            if ((xx == x + 1 && (yy == y + 1 || yy == y - 1)) && (a[xx][yy] >= 'A' && a[xx][yy] <= 'Z')) return 1;
            else if (yy != y) return 0;
            //miscare normala si dubla
            if ((x == 2 && ((xx - x > 2 || xx - x < 1) || (a[4][y] && xx == x + 2))) || (x != 2 && (xx - x != 1 || a[x + 1][y]))) return 0;
            else return 1;
        }
        if (a[x][y] == 'P'){
            if (a[x - 1][y] != NULL && (a[x - 1][y + 1] == NULL && a[x - 1][y - 1] == NULL)) return 0;
            if ((xx == x - 1 && (yy == y + 1 || yy == y - 1)) && (a[xx][yy] >= 'a' && a[xx][yy] <= 'z')) return 1;
            else if (yy != y) return 0;
            if ((x == 7 && ((x - xx > 2 || x - xx < 1) || (a[5][y] && xx == x - 2))) || (x != 7 && (x - xx != 1 || a[x - 1][y]))) return 0;
            else return 1;
        }
    }
    else if (a[x][y] == 'r' || a[x][y] == 'R'){
        //nerespectarea liniei
        if (x != xx && y != yy) return 0;
        //miscare pe orizontala
        if (x == xx){
            if (y < yy)
                for (i = y + 1; i < yy; i ++)
                    if (a[x][i] != NULL) return 0;
            if (y > yy)
                for (i = y - 1; i > yy; i --)
                    if (a[x][i] != NULL) return 0;
            return 1;
        }
        //miscare pe verticala
        else if (y == yy){
            if (x < xx)
                for (i = x + 1; i < xx; i ++)
                    if (a[i][y] != NULL) return 0;
            if (x > xx)
                for (i = x - 1; i > xx; i --)
                    if (a[i][y] != NULL) return 0;
            return 1;
        }
        // pentru fiecare caz se verifica daca exista obstacole in drum
    }
    else if (a[x][y] == 'k' || a[x][y] == 'K'){
        // impiedica capturarea propriilor piese
        if ((a[x][y] == 'k' && a[xx][yy] >= 'a' && a[xx][yy] <= 'z') || (a[x][y] == 'K' && a[xx][yy] >= 'A' && a[xx][yy] <= 'Z')) return 0;
        // impiedica deplasarea cu mai mult de 1 patratica
        if (abs(xx - x) > 1 || abs(yy - y > 1)) return 0;
        return 1;
    }
    else if (a[x][y] == 'b' || a[x][y] == 'B'){
        // impiedica nerespectarea diagonalei
        if (abs(xx - x) != abs(yy - y)) return 0;
        // se verifica traseul
        //diagonala sus-stanga
        if (xx < x && yy < y){
            for (i = x - 1, j = y - 1; i > xx && j > yy; i --, j --)
                if (a[i][j]) return 0;
        }
        //diagonala sus-dreapta
        else if (xx < x && yy > y){
            for (i = x - 1, j = y + 1; i > xx && j < yy; i --, j ++)
                if (a[i][j]) return 0;
        }
        //diagonala jos-stanga
        else if (xx > x && yy < y){
            for (i = x + 1, j = y - 1; i < xx && j > yy; i ++, j --)
                if (a[i][j]) return 0;
        }
        //diagonala jos-dreapta
        else if (xx > x && yy > y){
            for (i = x + 1, j = y + 1; i < xx && j < yy; i ++, j ++)
                if (a[i][j]) return 0;
        }
        return 1;
    }
    else if (a[x][y] == 'n' || a[x][y] == 'N'){
        if ((abs(x - xx) == 2 && abs(y - yy) == 1) || (abs(x - xx) == 1 && abs(y - yy) == 2)) return 1;
        return 0;
    }
    else if (a[x][y] == 'q' || a[x][y] == 'Q'){
        //miscare pe orizontala
        if (x == xx){
            if (y < yy)
                for (i = y + 1; i < yy; i ++)
                    if (a[x][i]) return 0;
            if (y > yy)
                for (i = y - 1; i > yy; i --)
                    if (a[x][i]) return 0;
            return 1;
        }
        //miscare pe verticala
        else if (y == yy){
            if (x < xx)
                for (i = x + 1; i < xx; i ++)
                    if (a[i][y]) return 0;
            if (x > xx)
                for (i = x - 1; i > xx; i --)
                    if (a[i][y]) return 0;
            return 1;
        }
        else if (abs(xx - x) != abs(yy - y)) return 0;
        // pentru fiecare caz se verifica daca exista obstacole in drum
        //diagonala sus-stanga
        else if (xx < x && yy < y){
            for (i = x - 1, j = y - 1; i > xx && j > yy; i --, j --)
                if (a[i][j]) return 0;
        }
        //diagonala sus-dreapta
        else if (xx < x && yy > y){
            for (i = x - 1, j = y + 1; i > xx && j < yy; i --, j ++)
                if (a[i][j]) return 0;
        }
        //diagonala jos-stanga
        else if (xx > x && yy < y){
            for (i = x + 1, j = y - 1; i < xx && j > yy; i ++, j --)
                if (a[i][j]) return 0;
        }
        //diagonala jos-dreapta
        else if (xx > x && yy > y){
            for (i = x + 1, j = y + 1; i < xx && j < yy; i ++, j ++)
                if (a[i][j]) return 0;
        }
    }
    return 1;
}
void square_select_alb(bool &cedat){
    while (1){
        if (GetAsyncKeyState(0xBB) & 0x0001) remalb = 1; // ask draw / confirm draw
        if (remneg && remalb) return;
        if (GetAsyncKeyState(0xBD) & 0x0001) {cout << "\nALBUL A CEDAT. "; reluare = 0; Sleep(5000); cedat = 1; return;} // forfeit
        if (GetAsyncKeyState('W') & 0x0001) cursor[0] --;
        if (GetAsyncKeyState('S') & 0x0001) cursor[0] ++;
        if (GetAsyncKeyState('A') & 0x0001) cursor[1] --;
        if (GetAsyncKeyState('D') & 0x0001) cursor[1] ++;
        if (cursor[0] < 1) cursor[0] ++;
        if (cursor[0] > 8) cursor[0] --;
        if (cursor[1] < 1) cursor[1] ++;
        if (cursor[1] > 8) cursor[1] --;
        afisare();
        if (GetAsyncKeyState(VK_SPACE) & 0x0001) return;
    }
}
void square_select_negru(bool &cedat){
    while (1){
        if (GetAsyncKeyState(0xBB) & 0x0001) remneg = 1; // ask draw / confirm draw
        if (remneg && remalb) return;
        if (GetAsyncKeyState(0xBD) & 0x0001) {cout << "\nNEGRUL A CEDAT. "; reluare = 0; Sleep(5000); cedat = 1; return;} // forfeit
        if (GetAsyncKeyState('W') & 0x0001) cursor[0] --;
        if (GetAsyncKeyState('S') & 0x0001) cursor[0] ++;
        if (GetAsyncKeyState('A') & 0x0001) cursor[1] --;
        if (GetAsyncKeyState('D') & 0x0001) cursor[1] ++;
        if (cursor[0] < 1) cursor[0] ++;
        if (cursor[0] > 8) cursor[0] --;
        if (cursor[1] < 1) cursor[1] ++;
        if (cursor[1] > 8) cursor[1] --;
        afisare();
        if (GetAsyncKeyState(VK_SPACE) & 0x0001) return;
    }
}
int main()
{
    ShowConsoleCursor(false);
    intro();
    while(1){
        if (GetAsyncKeyState('H') & 0x0001){
            help();
        }
        if (GetAsyncKeyState(VK_ESCAPE) & 0x0001){
            outro();
            return 0;
        }
        if (GetAsyncKeyState(VK_SPACE) & 0x0001){
            system("cls");
            loading();
            setup();
            afisare();
            reluare = 1;
                while (reluare){
                    if (mutare){
                        x = y = 0; xx = yy = 0;
                        afisare();
                        if (remalb == 1) remalb = 0;
                        square_select_alb(cedat);
                        if (cedat) break;
                        if (remneg && remalb) {cout << "\nREMIZA. "; reluare = 0; Sleep(5000); MainMenu(); break;}
                        x = cursor[0];
                        y = cursor[1];
                        afisare();
                        square_select_alb(cedat);
                        if (cedat) break;
                        if (remneg && remalb) {cout << "\nREMIZA. "; reluare = 0; Sleep(5000); MainMenu(); break;}
                        xx = cursor[0];
                        yy = cursor[1];
                        veriff = verif();
                        if (veriff == 0) remalb = 0;
                        if (veriff == 1 && a[xx][yy] == 'k') {system("cls"); cout << "\n\nALBUL A CASTIGAT\n"; recitire = 0; Sleep(3000); break;}
                        if (a[x][y] == 'K' && veriff == 1) rocadalb = 0;
                        if (veriff == 1) a[xx][yy] = a[x][y], mutare = 0, a[x][y] = NULL;
                        if (veriff == 1 && a[xx][yy] == 'P' && x - xx == 2) ep[0] = x - 1, ep[1] = y;
                        else if (veriff == 1) ep[0] = -1, ep[1] = -1;
                        else for (i = 1; i <= n; i ++) for (j = 1; j <= n; j ++) if (a[i][j] == 'E') a[i][j] = NULL;
                    }
                    else{
                        x = y = 0; xx = yy = 0;
                        afisare();
                        if (remneg == 1) remneg = 0;
                        square_select_negru(cedat);
                        if (cedat) break;
                        if (remneg && remalb) {cout << "\nREMIZA. "; reluare = 0; Sleep(5000); MainMenu(); break;}
                        x = cursor[0];
                        y = cursor[1];
                        afisare();
                        square_select_negru(cedat);
                        if (cedat) break;
                        if (remneg && remalb) {cout << "\nREMIZA. "; reluare = 0; Sleep(5000); MainMenu(); break;}
                        xx = cursor[0];
                        yy = cursor[1];
                        veriff = verif();
                        if (veriff == 0) remneg = 0;
                        if (veriff == 1 && a[xx][yy] == 'K') {system("cls"); cout << "\n\nNEGRUL A CASTIGAT\n"; recitire = 0; Sleep(3000); break;}
                        if (a[x][y] == 'k' && veriff == 1) rocadneg = 0;
                        if (veriff == 1) a[xx][yy] = a[x][y], mutare = 1, a[x][y] = NULL;
                        if (veriff == 1 && a[xx][yy] == 'p' && xx - x == 2) ep[0] = x + 1, ep[1] = y;
                        else if (veriff == 1) ep[0] = -1, ep[1] = -1;
                        else for (i = 1; i <= n; i ++) for (j = 1; j <= n; j ++) if (a[i][j] == 'e') a[i][j] = NULL;
                    }
                    afisare();
                }
                cout << "Apasa orice tasta pentru a te intoarce la meniul principal";
                hhh = getch();
                mutare = 1;
                MainMenu();
            }
    }
    return 0;
}
